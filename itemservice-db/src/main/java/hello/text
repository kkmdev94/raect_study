분석을 할때의 순서

도메인 우선 분석 -> 리포지토리 분석 -> 서비스 분석 -> 컨트롤러 분석

DTO(data transfer object)
 - 데이터 전송 객체
 - DTO는 기능은 없고 데이터 전달만 하는 용도로 사용되는 객체
    1) 참고로 DTO에 기능이 있으면 안되는가에 대한 질문으로는 '아니오'라고 대답. 객체의 주 목적이 데이터를 전송하는 것이라면 DTO라 불린다
 - 객체 이름에 DTO를 꼭 붙여야 하는 것은 아니지만 붙여놓으면 용도를 알 기 쉽다.
 - 이전 설명된 ItemSearchCond도 DTO이지만 이 프로젝트에서 Cond는 검색 조건으로 사용한다는 규칙을 정해 DTO를 안붙힘.
 - 관례나 규칙으로 정해진것은 아니므로 프로젝트 안에서 일관성 있는 규칙을 정하면 된다.

스프링 DI, 인터페이스, 상속에 대한 핵심 정리 (Q&A)
Q1. 서비스(ItemServiceV1)는 인터페이스(ItemRepository)만 아는데, 어떻게 특정 구현체(MemoryItemRepository)를 사용하고, 나중에 다른 DB 기술(JDBC, JPA)로 바꿀 수 있나요?
A1. 이 마법의 핵심은 스프링 컨테이너와 **의존관계 주입(Dependency Injection, DI)**입니다.
  1.역할과 배우의 분리: 서비스는 ItemRepository라는 **역할(인터페이스)**만 필요로 합니다. 이 역할을 누가 수행할지(어떤 **배우(구현체)**가 연기할지)는 신경 쓰지 않습니다.
  2.스프링의 역할(감독): 애플리케이션이 시작될 때, 스프링 컨테이너는 @Repository 같은 어노테이션이 붙은 모든 클래스를 스캔해서 **빈(Bean)**으로 등록합니다. 이때 MemoryItemRepository가 빈으로 등록 됩니다.
  3.의존관계 주입(캐스팅): 스프링은 ItemServiceV1을 만들 때, 생성자에서 ItemRepository 타입의 빈이 필요하다는 것을 확인합니다. 그리고 자신이 관리하는 빈 중에서 ItemRepository 역할을 할 수 있는
    MemoryItemRepository를 찾아서 **주입(연결)**해 줍니다.
  4.자유로운 교체: 나중에 JdbcItemRepository를 만들고 @Repository를 붙인 뒤, 기존 MemoryItemRepository의 @Repository를 주석 처리하면, 스프링은 다음 실행 때 JdbcItemRepository를 주입해 줍니다. 서비스 코드는 단 
    한 줄도 바꿀 필요가 없습니다.
Q2. 상속(extends)과 구현(implements)의 핵심적인 차이는 무엇인가요?
A2. "상속은 기능을 빼먹어도 되지만, 구현은 안된다"고 이해하신 것이 거의 맞습니다. 더 정확히는 다음과 같습니다.•구현 (Implements): **"계약"**입니다. 
      인터페이스에 정의된 모든 메소드(기능)를 하나도 빠짐없이 반드시 만들어야 하는 의무가 있습니다. 하나라도 빼먹으면 컴파일 오류가 발생합니다.
   •상속 (Extends): **"유산"**입니다. 부모의 모든 기능(public, protected)을 자동으로 물려받습니다. 자식 클래스에서 코드를 작성하지 않는 것은 "기능을 빼먹는 것"이 아니라, **"물려받은 기능을 그대로 사용하겠다"**는 의
                          미입니다. 물론, 마음에 안 들면 재정의(@Override)해서 바꿀 수도 있습니다.
Q3. 메소드를 호출하면 어떤 순서로 찾아가나요? 상속받은 부모 클래스로 바로 가나요?
A3. 아니요, 자기 자신부터 찾아봅니다. 메소드 탐색 순서는 다음과 같습니다.
  1.1순위 (자기 자신): 호출된 객체의 클래스(SuperCar) 내부에 해당 메소드가 있는지 먼저 찾습니다.
  2.2순위 (부모): 자기 자신에게 메소드가 없으면, 상속받은 부모 클래스(Car)로 올라가서 찾습니다.
  3.반복: 부모에도 없으면 그 부모의 부모로 계속 올라갑니다. (최종적으로는 Object 클래스까지)
  4.오류: 최상위 부모까지 찾아봤는데도 메소드가 없으면, 컴파일러가 "그런 메소드는 찾을 수 없습니다"라는 오류를 발생시킵니다.
Q4. @Override 어노테이션은 언제 사용하고, 왜 중요한가요?
A4. @Override는 **"부모(클래스 또는 인터페이스)로부터 물려받은 기능을 변경하거나 완성한다"**는 명시적인 표시이며, 두 가지 상황 모두에서 사용됩니다.
   •상속 관계에서: 부모에게 물려받은 기능을 자식의 입맛에 맞게 **변경(재정의)**할 때 사용합니다.
   •구현 관계에서: 인터페이스에 정의된 '빈 껍데기' 메소드를 **완성(구현)**할 때 사용합니다.@Override는 단순한 주석이 아니라, 컴파일러에게 "내가 재정의하려는 이 메소드가 부모에게 정말 있는지 확인해 줘!"라고 요청
                         하는 안전장치 역할을 합니다. 만약 개발자가 메소드 이름을 실수로 잘못 적으면 컴파일 오류를 내주어 버그를 사전에 막아줍니다.


ItemServiceApplication에서 MemoryConfig를 호출! 이렇게 해서 Bean으로 등록한 Repository와 Service를 호출!!