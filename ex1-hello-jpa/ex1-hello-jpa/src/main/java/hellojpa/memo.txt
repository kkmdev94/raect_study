영속성 컨텍스트
 - JPA를 이해하는데 가장 중요한 용어
 - "엔티티를 영구 저장하는 환경" 이라는 뜻
 - EntityManager.persist(entity);

 - 이점
   1. 1차 캐시
   2. 동일성(identity) 보장
   3. 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)
   4. 변경 감지(Dirty Checking)
   5. 지연 로딩(Lazy Loading)

 - 영속성 컨텍스트
   1. 논리적인 개념
   2. 눈에 보이지 않는다
   3. 엔티티 매니저를 통해서 영속성 컨텍스트에 접근.

  - 엔티티의 생명주기
   1. 비영속(new / transient)
     영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
   2. 영속(managed)
     영속성 컨텍스트에 관리되는 상태
   3. 준영속(detached)
     영속성 컨텍스트에 저장되었다가 분리된 상태
   4. 삭제(removed)
     삭제된 상태

플러시
  - 영속성 컨텍스트를 비우지 않는다!
  - 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화!
  - 트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화 하면 됨.

준영속 상태
  - 영속 -> 준영속
  - 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)
  - 영속성 컨텍스트가 제공하는 기능 사용 못함

연관관계의 주인(Owner)
 - 양방향 매핑 규칙
    - 객체의 두 관계 중 하나를 연관관계의 주인으로 지정
    - 연관관계의 주인만이 외래 키를 관리(등록, 수정)
    - 주인이 아닌쪽은 읽기만 가능
    - 주인은 mappedBy 속성 사용 X
    - 주인이 아니면 mappedBy 속성으로 주인 지정.
    - 1대 다 / 다 대 1 에서 즉 다 쪽이 연관관계의 주인이 된다고 보면 된다.
    즉, DB는 FK하나로 join을 통해서 데이터 핸들링이 가능하지만 객체는 예시에서 나온것 처럼 Member는 Team을 참조하고 Team은 Members를 참조하는 과정에서
    어느 누구를 기준으로 삼아서 맵핑을 해야하는지 혼란스러워 지기 때문에 mappedBy 속성을 이용하여 누구에게 관리되고 있다는 것을 표시한다.
    mappedBy가 적힌 곳은 주인이 아니므로 읽기만 가능하다!

    그렇다면 주인은 누구를 잡아야 하는가에 대해서는 외래 키가 있는 곳을 주인으로 정한다.
    즉, 멤버 엔티티랑 멤버 테이블을 맵핑을 했을때 DB에서는 Member 테이블에 TEAM_ID가 FK로 있기에 FK가 있는곳을 주인으로 지정해야 한다.
