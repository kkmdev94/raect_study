영속성 컨텍스트
 - JPA를 이해하는데 가장 중요한 용어
 - "엔티티를 영구 저장하는 환경" 이라는 뜻
 - EntityManager.persist(entity);

 - 이점
   1. 1차 캐시
   2. 동일성(identity) 보장
   3. 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)
   4. 변경 감지(Dirty Checking)
   5. 지연 로딩(Lazy Loading)

 - 영속성 컨텍스트
   1. 논리적인 개념
   2. 눈에 보이지 않는다
   3. 엔티티 매니저를 통해서 영속성 컨텍스트에 접근.

  - 엔티티의 생명주기
   1. 비영속(new / transient)
     영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
   2. 영속(managed)
     영속성 컨텍스트에 관리되는 상태
   3. 준영속(detached)
     영속성 컨텍스트에 저장되었다가 분리된 상태
   4. 삭제(removed)
     삭제된 상태

플러시
  - 영속성 컨텍스트를 비우지 않는다!
  - 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화!
  - 트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화 하면 됨.

준영속 상태
  - 영속 -> 준영속
  - 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)
  - 영속성 컨텍스트가 제공하는 기능 사용 못함

연관관계의 주인(Owner)
 - 양방향 매핑 규칙
    - 객체의 두 관계 중 하나를 연관관계의 주인으로 지정
    - 연관관계의 주인만이 외래 키를 관리(등록, 수정)
    - 주인이 아닌쪽은 읽기만 가능
    - 주인은 mappedBy 속성 사용 X
    - 주인이 아니면 mappedBy 속성으로 주인 지정.
    - 1대 다 / 다 대 1 에서 즉 다 쪽이 연관관계의 주인이 된다고 보면 된다.
    즉, DB는 FK하나로 join을 통해서 데이터 핸들링이 가능하지만 객체는 예시에서 나온것 처럼 Member는 Team을 참조하고 Team은 Members를 참조하는 과정에서
    어느 누구를 기준으로 삼아서 맵핑을 해야하는지 혼란스러워 지기 때문에 mappedBy 속성을 이용하여 누구에게 관리되고 있다는 것을 표시한다.
    mappedBy가 적힌 곳은 주인이 아니므로 읽기만 가능하다!

    그렇다면 주인은 누구를 잡아야 하는가에 대해서는 외래 키가 있는 곳을 주인으로 정한다.
    즉, 멤버 엔티티랑 멤버 테이블을 맵핑을 했을때 DB에서는 Member 테이블에 TEAM_ID가 FK로 있기에 FK가 있는곳을 주인으로 지정해야 한다.

 양방향 매핑 정리
   - 단방향 매핑만으로도 이미 연관관계 매핑은 완료이다.
     - 설계를 하면서 테이블 관계와 함께 외래키가 다 나오고, 일 대 다 관계도 나타나는데 이때, 애니투원이나 원투원 관계에서 초기에는 절대 양방향 매핑을 하지 말것.
       처음에는 무조건 단방향 매핑으로 설계를 완료해야 한다. 양방향 매핑은 반대 방향으로 조회 기능이 추가되는 것을 의미,
       즉 JPA에서의 설계는 객체와 테이블 간의 매핑이 단방향 매핑만으로 이미 완료가 된것.
   - JPQL에서 역방향으로 탐색할 일이 많음 / 단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 된다.(테이블에 영향을 주지 않는다)

일대일
 - 일대일 관계는 그 반대도 일대일
 - 주 테이블이나 대상 테이블 중에 외래 키 선택 가능
   1. 주 테이블에 외래 키
   2. 대상 테이블에 외래 키
 - 외래 키에 데이터베이스 유니크(UNI) 제약조건 추가.
 - OneToOne에서 대상 테이블에 외래 키 단방향 즉 일대다 같은 형상은 애초에 지원을 안하기에 불가능하다.

다대다
 - 실무에서 사용 X
 - 한계를 극복하기 위해 연결 테이블용 엔티티 추가(즉, 연결테이블을 조인테이블을 통해서 안보이는 테이블을 생성하는게 아닌, 엔티티로 승격시킨 하나의 엔티티를 하나 만든다)
 - 즉, ManyToMany를 @OneToMany, @ManyToOne으로 엔티티 생성