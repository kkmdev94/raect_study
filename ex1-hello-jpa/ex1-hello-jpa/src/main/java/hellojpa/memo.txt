영속성 컨텍스트
 - JPA를 이해하는데 가장 중요한 용어
 - "엔티티를 영구 저장하는 환경" 이라는 뜻
 - EntityManager.persist(entity);

 - 이점
   1. 1차 캐시
   2. 동일성(identity) 보장
   3. 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)
   4. 변경 감지(Dirty Checking)
   5. 지연 로딩(Lazy Loading)

 - 영속성 컨텍스트
   1. 논리적인 개념
   2. 눈에 보이지 않는다
   3. 엔티티 매니저를 통해서 영속성 컨텍스트에 접근.

  - 엔티티의 생명주기
   1. 비영속(new / transient)
     영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
   2. 영속(managed)
     영속성 컨텍스트에 관리되는 상태
   3. 준영속(detached)
     영속성 컨텍스트에 저장되었다가 분리된 상태
   4. 삭제(removed)
     삭제된 상태

플러시
  - 영속성 컨텍스트를 비우지 않는다!
  - 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화!
  - 트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화 하면 됨.

준영속 상태
  - 영속 -> 준영속
  - 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)
  - 영속성 컨텍스트가 제공하는 기능 사용 못함

연관관계의 주인(Owner)
 - 양방향 매핑 규칙
    - 객체의 두 관계 중 하나를 연관관계의 주인으로 지정
    - 연관관계의 주인만이 외래 키를 관리(등록, 수정)
    - 주인이 아닌쪽은 읽기만 가능
    - 주인은 mappedBy 속성 사용 X
    - 주인이 아니면 mappedBy 속성으로 주인 지정.
    - 1대 다 / 다 대 1 에서 즉 다 쪽이 연관관계의 주인이 된다고 보면 된다.
    즉, DB는 FK하나로 join을 통해서 데이터 핸들링이 가능하지만 객체는 예시에서 나온것 처럼 Member는 Team을 참조하고 Team은 Members를 참조하는 과정에서
    어느 누구를 기준으로 삼아서 맵핑을 해야하는지 혼란스러워 지기 때문에 mappedBy 속성을 이용하여 누구에게 관리되고 있다는 것을 표시한다.
    mappedBy가 적힌 곳은 주인이 아니므로 읽기만 가능하다!

    그렇다면 주인은 누구를 잡아야 하는가에 대해서는 외래 키가 있는 곳을 주인으로 정한다.
    즉, 멤버 엔티티랑 멤버 테이블을 맵핑을 했을때 DB에서는 Member 테이블에 TEAM_ID가 FK로 있기에 FK가 있는곳을 주인으로 지정해야 한다.

 양방향 매핑 정리
   - 단방향 매핑만으로도 이미 연관관계 매핑은 완료이다.
     - 설계를 하면서 테이블 관계와 함께 외래키가 다 나오고, 일 대 다 관계도 나타나는데 이때, 애니투원이나 원투원 관계에서 초기에는 절대 양방향 매핑을 하지 말것.
       처음에는 무조건 단방향 매핑으로 설계를 완료해야 한다. 양방향 매핑은 반대 방향으로 조회 기능이 추가되는 것을 의미,
       즉 JPA에서의 설계는 객체와 테이블 간의 매핑이 단방향 매핑만으로 이미 완료가 된것.
   - JPQL에서 역방향으로 탐색할 일이 많음 / 단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 된다.(테이블에 영향을 주지 않는다)

일대일
 - 일대일 관계는 그 반대도 일대일
 - 주 테이블이나 대상 테이블 중에 외래 키 선택 가능
   1. 주 테이블에 외래 키
   2. 대상 테이블에 외래 키
 - 외래 키에 데이터베이스 유니크(UNI) 제약조건 추가.
 - OneToOne에서 대상 테이블에 외래 키 단방향 즉 일대다 같은 형상은 애초에 지원을 안하기에 불가능하다.

다대다
 - 실무에서 사용 X
 - 한계를 극복하기 위해 연결 테이블용 엔티티 추가(즉, 연결테이블을 조인테이블을 통해서 안보이는 테이블을 생성하는게 아닌, 엔티티로 승격시킨 하나의 엔티티를 하나 만든다)
 - 즉, ManyToMany를 @OneToMany, @ManyToOne으로 엔티티 생성


프록시
  - em.find() vs em.getReference()
    1. em.find : 데이터베이스를 통해서 실제 엔티티 객체 조회
    2. em.getReference : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회
  - getReference를 실행해보면 select 쿼리가 나가지 않는다. 하지만 예제처럼 DB에 있는 값을 가져와서 보여줄때는 필요해서 프록시를 사용.
  - 껍데기는 똑같은데 안이 텅텅 빈 객체이다. 내부에는 Target이라는게 진짜 레퍼런스를 가르킨다.

  -특징
    1. 실제 클래스를 상속받아서 만들어짐
    2. 실제 클래스와 겉 모양이 같다
    3. 사용자 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 됨(이론상)

    1). 프록시 객체는 처음 사용할 때 한 번만 초기화
    2). 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능
    3). 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함(== 비교 실패, 대신 instance of 사용)
    4). 영속성 컨텍스트에 찾는 엔티티가 이미 있으면  em.getReference()를 호출해도 실제 엔티티 반환
    5). 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 떄, 프록시 초기화 문제 발생(하이버네이트는 org.hibernate.LazyInitializationException 예외 발생)

  - 프록시와 즉시로딩 주의
    1. 가급적 지연 로딩만 사용(특히 실무에서)
    2. 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생
    3. 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다.
    4. @ManyToOne, @OneToOne은 기본이 즉시 로딩 -> LAZY로 설정
    5. @OneToMany, @ManyToMany는 기본이 지연 로딩.

  - 지연 로딩 활용(이론상 예시 - 실무에서는 지연로딩으로 사용해야 한다.)
    1. Member와 Team은 자주 함께 사용 -> 즉시 로딩
    2. Member와 Order는 가끔 사용 -> 지연 로딩
    3. Order와 Product는 자주 함께 사용 -> 즉시 로딩

  - 지연 로딩 활용 - 실무
    1. 모든 연관관계에 지연 로딩을 사용해라!
    2. 시룸에서 즉시 로딩을 사용하지 마라!
    3. JPQL fetch 조인이나, 엔티티 그래프 기능을 사용해라!(뒤에 서술)
    4. 즉시 로딩은 상상하지 못한 쿼리가 나간다.

영속성 전이 : CASCADE
  - 특정 엔티티를 영속 상태로 만들 떄 연관된 엔티티도 함께 영속 상태로 만들고 싶을 때
        ex) 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장.
  - 주의점
    1.영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없다.
    2. 엔티티를 영속화 할 때 연관된 엔티티도 함께 영속화하는 편리함을 제공할 뿐.
    3. 소유자가 하나일때만 사용, 예시처럼 부모가 자식을 사용하면 문제가 없지만, 다른 부모가 같은 자식을 사용하면 그것은 문제가 발생하기에 이때는 사용 X
  - 종류 (더 있지만 3가지만 주로 사용)
    1. ALL : 모두 적용
    2. PERSIST : 영속
    3. REMOVE : 삭제

고아 객체
  - 고아 객체 제거 : 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제
  - orphanRemoval = true
  - Parent parent1 = em.find(Parent.class, id);
    parent1.getChildren().remove(0); // 자식 엔티티를 컬렉션에서 제거

  -고아 객체 - 주의
    1. 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능
    2. 참조하는 곳이 하나일 때 사용해야함!
    3. 특정 엔티티가 개인 소유할 때 사용
    4. @OneToOne, @OneToMany만 가능
    5. 개념적으로 부모를 제거하면 자식은 고아가 되므로 객체 제거 기능을 활성화 하면, 부모를 제거할때 자식도 함께 제거가 된다.
       CascadeType.REMOVE처럼 동작한다.

  -영속성 전이 + 고아 객체, 생명주기
    1. CascadeType.ALL + orphanRemovel=true
    2. 스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거
    3. 두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있음
    4. 도메인 주도 설계(DDD)의 Aggregate Root 개념을 구현할 때 유용

임베디드 타입
  - 임베디드 타입은 엔티티의 값일 뿐이다
  - 임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같다
  - 객체와 테이블을 아주 세밀하게(find0grained) 매핑하는 것이 가능
  - 잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많음.